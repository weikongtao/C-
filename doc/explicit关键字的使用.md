# explicit关键字

在 C++ 中，`explicit` 关键字用于声明**类型转换运算符**和只能显式调用的**单参数构造函数**。主要的作用是防止编译器进行**隐式类型转换**，从而避免一些意外的行为和不确定性。

具体而言，`explicit`关键字的作用主要有以下几个方面：

1. **防止隐式类型转换：** 当一个构造函数被声明为 `explicit` 时，它将不能被用于隐式类型转换。这意味着在需要使用该构造函数创建对象时，必须显式地调用该构造函数，而不能通过隐式类型转换来隐式地创建对象。
2. **避免意外的行为：** 隐式类型转换可能会导致一些意外的行为，特别是在涉及到类型转换时。通过使用 `explicit` 关键字，可以避免这种情况的发生，使代码更加清晰明了，减少错误的可能性。
3. **提高代码的可读性和健壮性：** 使用 `explicit` 关键字可以明确地表达代码的意图，使代码更易读、易理解，并且可以帮助防止一些潜在的错误。这有助于提高代码的健壮性和可维护性。

## explicit的使用

举例而言：

假设有一个类`MyData`，有构造函数可以将string类型的参数转换为`MyData`类型：

```c++
class MyData{
public:
    MyData(const string& str):_data(str){}
private:
    int _data;
}
```

我们可以通过以下方式来创建一个`MyData`对象：

```c++
MyData my_data = "wei"; //首先，string类型的“wei”发生隐式类型转换，生成一个MyData类型的临时对象；
                        //其次，该临时对象通过拷贝赋值运算符生成my_data
```

但是有些情况下，这种隐式类型转换并非我们所需，考虑如下函数：

```c++
void func(MyData str){
    // do something
}

//调用以上函数
func("wei");  //发生隐式类型转换
```

我们不希望`func`函数可以接收string类型参数，该函数只接收`MyData`类型的实参，这种情况下，就需要使用`explicit`：

```c++
class MyData{
public:
    explicit MyData(const string& str):_data(str){}
private:
    int _data;
}
```

这样，以上的调用就会导致编译错误，因为隐式类型转换不被允许，必须使用显示转换：

```c++
func(Mydata("wei"));
```

所以，可以使用`explicit`关键字来防止不必要的隐式类型转换，提高代码可读性和安全性。

## 注意

- 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于隐式类型转换，所以无须将这些构造函数指定为explicit的。    

- 只能在类内声明单参构造函数时使用`explicit`关键字，在类外部定义时不应该重复：

  ```c++
  //错误：explicit关键字只允许出现在类内的构造函数声明处
  explicit Sales_data::Sales_data(istream& is){
      read(is, *this);
  }
  ```



## 总结

在类型定义中, **类型转换运算符**和**单参数构造函数**都应当用 `explicit` 进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为 `explicit`, 因为它们并不执行类型转换. 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的。

不能以一个参数进行调用的构造函数不应当加上 `explicit`。 接受一个 `std::initializer_list` 作为参数的构造函数也应当省略 `explicit`。以便支持拷贝初始化 (例如 `MyType m = {1, 2};`)。

